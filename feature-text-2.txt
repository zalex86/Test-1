17.2. Работа с файлами и коммитами
 Добавить страницу в мои закладки
→ Эта глава посвящена работе с файлами в СКВ. Вы узнаете, какие бывают статусы файлов, как отслеживаются изменения и как фиксируются изменения в Git.

Итак, мы создали репозиторий для хранения данных. Теперь нам надо научиться добавлять изменения в СКВ.

Поскольку Git был создан для работы с исходным кодом программного обеспечения, основными типами изменений, которые умеет отслеживать Git, являются:

Добавление новых файлов.
Удаление файлов.
Изменения в файлах с возможностью сравнения текста изменений для текстовых файлов.
Изменение прав доступа к файлам (например, в Linux и macOS — изменение, сделанное командой chmod 777).
С помощью Git также можно сравнивать сделанные изменения и откатывать их. Для просмотра изменений можно использовать как средства, предлагаемые клиентом Git (в нашем случае это консольный текстовый редактор), так и более user-friendly программы, например IDE по вашему выбору или специализированные программы для сравнения файлов.

В большинстве случаев работа с СКВ устроена примерно одинаково:

Получаем свежие данные репозитория (git clone  или git pull origin feature-branch).
Пишем код.
Когда есть определённый набор изменений, делаем коммит (изменения закрепляются) (git add и git commit).
Снова пишем код.
Снова коммитим код (git commit -am).
Делимся полученным результатом (git push origin feature-branch).
$ git clone https://github.com/yourname/xi-mac.git
Cloning into 'xi-mac'...
remote: Enumerating objects: 43, done.
remote: Counting objects: 100% (43/43), done.
remote: Compressing objects: 100% (40/40), done.
remote: Total 5408 (delta 12), reused 23 (delta 2), pack-reused 5365
Receiving objects: 100% (5408/5408), 4.47 MiB | 5.29 MiB/s, done.
Resolving deltas: 100% (3838/3838), done.
$ cd xi-mac
$ # редактируем код
$  git diff
diff --git a/README.md b/README.md
index dbedcbe..d6958d4 100644
--- a/README.md
+++ b/README.md
@@ -1,3 +1,5 @@
+it's a new change!
+
 [![Build Status](https://travis-ci.com/xi-editor/xi-mac.svg?branch=master)](https://travis-ci.com/xi-editor/xi-mac)
 [![codecov](https://codecov.io/gh/xi-editor/xi-mac/branch/master/graph/badge.svg)](https://codecov.io/gh/xi-editor/xi-mac)
$ git add .
$ git commit # пишем описание изменений в самой первой строке файла

# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
#
# On branch master
# Your branch is ahead of 'origin/master' by 1 commit.
#   (use "git push" to publish your local commits)
#
# Changes to be committed:
#   	modified:   README.md

$ # снова изменения
$ git commit
$ git pull origin master
$ git push origin https://github.com/yourname/xi-mac.git
Задание 17.2.1
1/1 point (graded)
Что сделает команда git clone https://github.com/xi-editor/xi-mac.git? Если не уверены в ответе, попробуйте выполнить её на своём компьютере.


Создаст пустую папку xi-mac.git в текущей директории
Создаст копию репозитория xi-mac.git с удалённого сервера в текущей папке
Создаcт копию репозитория xi-mac.git с удалённого сервера в папке xi-mac.git. Если такая папка существует, то она будет перезаписана
Создаcт копию репозитория xi-mac.git с удалённого сервера в папке xi-mac (при условии, что этой директории ещё нет) верно
ОтправитьВ некоторых задачах доступны следующие действия: сохранение, сброс, показ подсказки или ответа. Соответствующие кнопки расположены рядом с кнопкой «Отправить».

Показать Ответ
При использовании консольного клиента Git вам потребуются базовые навыки работы с консольным редактором текста (vim, nano или похожие). Если вы не уверены в своих навыках, то можно поменять этот редактор на какой-нибудь другой. 

Для этого необходимо выполнить команду.

На macOS вы можете использовать:

git config --global core.editor "open -W -n"
или

git config --global core.editor /Applications/TextEdit.app/Contents/MacOS/TextEdit
В Windows используйте:

git config --global core.editor C:\Полный путь до \notepad.exe
Теперь, когда вы введёте команду git commit, вам откроется более привычный для вас текстовый редактор:



Вне зависимости от того каким редактором вы пользуетесь, вам необходимо ввести описание коммита. Это сообщение может содержать сколько угодно строк, но все строки, начинающиеся с символа #, будут проигнорированы. 

Большинство пользователей делают примерно так, как на скриншоте:



После этого временный файл, открытый вашим текстовым редактором, нужно сохранить. В случае c macOS редактор нужно закрыть (об этом вам напомнит Git).

Обратите внимание! Сообщение о коммите не может быть пустым — в таком случае коммит будет считаться незавершённым (вы можете просто закрыть текстовый редактор без сохранения файла и продолжить вносить изменения, а закоммитить их потом).

СТАТУСЫ ФАЙЛОВ

Когда файл находится внутри директории-репозитория Git, ему присваивается определённый статус. Чтобы лучше понимать статусы файлов в Git, посмотрите внимательно на диаграмму ниже:



Мы подробнее рассмотрим её в скринкасте. Главное, что нужно знать об этой диаграмме — то, что перед коммитом все ваши изменения должны быть в статусе staged.


Задание 17.2.2
1/1 point (graded)
С помощью какой команды следует перемещать файлы внутри git-репозитория?


git rm, потом git add
Достаточно git add
git mv верно
git cp
Ответ
Верно:История изменений файла не потеряется: будет видно, что файл был переименован.
ОтправитьВ некоторых задачах доступны следующие действия: сохранение, сброс, показ подсказки или ответа. Соответствующие кнопки расположены рядом с кнопкой «Отправить».

Показать Ответ

КАК ЧАСТО НУЖНО ЗАКРЕПЛЯТЬ ИЗМЕНЕНИЯ?

Для эффективной работы изменения надо закреплять («коммитить») достаточно часто, чтобы разница между «снимками» вашего кода была не слишком большой и не слишком маленькой — умеренной.

Почему это важно? Всё дело в том, что Git позволяет легко «откатить» изменения и показать разницу между ними. 

Например, вы внесли существенные правки в файл конфигурации какого-то веб-сервера и он перестал работать правильно. Какая правка всё сломала? 

Предположим, что конфигурационный файл содержит десятки строк.

В первом варианте вы закоммитили его только в начальном и конечном состоянии. Теперь вам придётся почти построчно проверять каждое изменение. 

Во втором варианте вы коммитили файл буквально после каждой строчки и сделали много версий. Проверить их все — довольно трудоёмкая ручная работа, но, к счастью, есть инструменты, которые позволяют её автоматизировать. 

В третьем варианте вы изменяли логически связанные блоки конфигурации среднего объёма. Ошибка, с которой вам отвечает веб-сервер, может натолкнуть вас на идею о том, какое же изменение поломало его поведение. Сравнить изменения в пяти-семи строках гораздо проще, чем сделать это для сотни строк или сравнить одну строчку сто раз. Более того, подобные изменения будет проще проверить и охватить взглядом как вам самим, так и другим читателям.

Навык формирования списка изменений приходит с опытом. Чем чаще вы работаете с СКВ, тем лучше понимаете, какие изменения критичны и должны быть в отдельном небольшом коммите, а какие могут быть объединены в коммит большего объёма. 

→ В этой и следующей главе мы покажем, как изменять коммит и переносить изменения в другие ветки, сравнивать коммиты, менять историю коммитов (например, объединять их).

ИДЕНТИФИКАТОРЫ И ТЕГИ

Чтобы отличать один коммит от другого, Git присваивает каждому коммиту идентификатор. Этот идентификатор называется хеш коммита и выглядит примерно так: 91791fe13f087b9a15c20d86ccec21b36d8301cb. 

Когда нам нужно обратиться к какому-то коммиту, можно использовать как его полный идентификатор, так и его часть. Чаще всего используют первые четыре-шесть знаков в начале хеша; в нашем примере — 91791. Увидеть хеш коммита вы можете сразу после команды git commit или помощью команды git log:



Вы также можете присвоить коммиту тег — выбранное вами имя. Подобные имена часто используются для того, чтобы обозначить релизную версию программы.

Поскольку каждый идентификатор генерируется случайным образом, то вероятность того, что два коммита в одном репозитории будут иметь одинаковые первые шесть символов мала, но не равна нулю. В таком случае, если вы обратитесь к коммиту, используя сокращённый адрес, произойдёт коллизия — Git вам об этом сообщит. Вам придётся обратиться к такому коммиту? используя его полный хеш.

Вероятность совпадения хешей двух различных коммитов настолько мала, что может рассматриваться только в теоретическом аспекте.

КОНТРОЛЬНОЕ ЗАДАНИЕ

В предыдущей главе вы создали репозиторий на github и получили его к себе на локальную машину.

В своём репозитории создайте файл INFO.md и постарайтесь записывать туда все команды, которые вы выполняете из командой строки вместе с их кратким описанием.
Создайте файл file-feature-1.txt с произвольным содержимым (например, текст из предыдущей главы) и зафиксируйте его в Git.
После этого создайте файл file-feature-2.txt с другим содержимым (например, текст из этой главы). Вновь измените файл file-feature-1.txt. Снова зафиксируйте его в Git.
Теперь создайте file-feature-3.txt (произвольный текст) и удалите file-feature-1.txt. Зафиксируйте это изменение. Обратите внимание: вы можете зафиксировать удаление файла через git add или через git delete.
Теперь переименуйте файл file-feature-3.txt в file-main-feature.txt, используя git mv.
Мы ожидаем, что в вашем репозитории будет четыре коммита и три файла. У каждого коммита должно быть осмысленное описание того, что вы хотели сделать.

После того, как все изменения зафиксированы, выполните команду: 

git push origin master
Так вы отправите все изменения на сервер.

Помните, что вы почти всегда можете отменить любое изменение в своём репозитории с помощью git checkout и git reset. Но если вы совершенно точно уверены, что сломали абсолютно всё, то снова склонируйте репозиторий.

Если вам необходима консультация, вы всегда можете обратиться к ментору с вопросом.